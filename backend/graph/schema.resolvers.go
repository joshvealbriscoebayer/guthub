package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.24

import (
	"context"
	"database/sql"
	"fmt"
	"log"

	"github.com/TutorialEdge/realtime-chat-go-react/graph/model"
	_ "github.com/lib/pq"
)

// UpsertUser is the resolver for the upsertUser field.
func (r *mutationResolver) UpsertUser(ctx context.Context, input model.UserInput) (*model.User, error) {
	var user model.User
	user.Email = input.Email
	user.Password = input.Password
	user.Followers = make([]*string, 0)
	user.Following = make([]*string, 0)

	n := len(r.Resolver.UserStore)
	if n == 0 {
		r.Resolver.UserStore = make(map[string]model.User)
	}

	r.Resolver.UserStore[user.Email] = user

	return &user, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, email string) (*model.UserOutput, error) {
	var followers []*string
	var following []*string
	var password string
	var user model.UserOutput

	connStr := "postgresql://postgres:mysecretpassword@localhost/postgres?sslmode=disable"
	// Connect to database
	db, err := sql.Open("postgres", connStr)
	if err != nil {
		log.Fatal(err)
	}

	rows, err := db.Query(fmt.Sprintf("SELECT password, followers, following FROM users WHERE email='%v'", email))
	defer rows.Close()
	db.Close()
	
	for rows.Next() {
		rows.Scan(&followers, &following, &password)
	
		user.Email = email
		user.Followers = followers
		user.Following = following
	}
	
	// user, ok := r.Resolver.UserStore[email]

	// if !ok {
	// 	return nil, fmt.Errorf("not found")
	// }

	// var userOutput model.UserOutput
	// userOutput.Email = email
	// userOutput.Followers = user.Followers
	// userOutput.Following = user.Following

	return &user, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context) ([]*model.UserOutput, error) {
	users := make([]*model.UserOutput, 0)
	for idx := range r.Resolver.UserStore {
		user := r.Resolver.UserStore[idx]

		var userOutput model.UserOutput
		userOutput.Email = user.Email
		userOutput.Followers = user.Followers
		userOutput.Following = user.Following

		users = append(users, &userOutput)
	}

	return users, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
